---
layout: post
title: Record
categories: misc
author: Nicola Santi
JEPs: [395]
references:
    - title: A Comprehensive Guide to Java Records
      url: https://medium.com/@mak0024/a-comprehensive-guide-to-java-records-2e8edcbd9c75
---

Many languages, especially those more oriented to numerical analysis, offer data structures called tuples whose main characteristic is immutability. Let's look at an example in python:

```python
box1 = ("Alice", 1)
```

They can contain a list of any type, even different ones, and can also be structured hierarchically:

```python
box2 = ("Bob", 2)
depot = ([box1, box2],)
```

The individual fields of a tuple can also be named.

```python
class Box(NamedTuple):
    owner: str
    id: int

class Depot(NamedTuple):
    boxes: List[Box]

box1 = Box(owner="Alice", id=1)
box2 = Box(owner="Bob", id=2)

depot = Depot(boxes=[box1, box2])
```

In any case, once instantiated, the content of a tuple is __immutable__. 

Until JDK 16, Java did not offer any shortcuts for this type of semantics, forcing us to declare final classes with final fields and implement the *hashCode()* and *equals()* methods in order to compare them correctly. 

La keyword __record__ risolve questa esigenza:

```java
public record Box(String owner, int id) {}
```

Behind the scenes, the compiler generates this class for us:

```java
 public final class Box extends java.lang.Record {
            //Canonical constructor
            public Box(java.lang.String, int); 
            
            public final java.lang.String toString();
            public final int hashCode();
            public final boolean equals(java.lang.Object);
            
            //not JavaBean getters, e.g. getOwner() or getId()
            public java.lang.String owner();
            public int id();
}
```
We note the immutability of fields and classes (via the keyword final) and the automatic generation of methods for comparing records. As mentioned, the semantics behind this type is that of an __immutable named tuple__. 

The developer is called upon to guarantee this semantics by avoiding code similar to the following:

```java
public record Box(String owner, int id) {
    
    public String owner() {
            return "Not the real field value.";
    }
}

```

A record may contain a hierarchical structure, like any other class.

```java
public record Box(String owner, int id) {}
public record Depot(List<Box> boxes) {}

Depot depot = new Depot(List.of(
        new Box("Nicola", 1),
        new Box("Mattia", 2)));
    
```

As we have seen, it is possible to add static methods or overload them. Of these, constructors 
are of particular importance.

## Constructors

Traditionally, Java provided two types of constructors:

* default constructor: it merely instantiates the class and is added automatically by compiler in the absence of other constructors; 
* custom constructor: a method written __ad hoc__ by the developer;

Records add a third type of constructor called __canonical__, which receives input values for all fields and is automatically generated by the compiler (only for records, not for other classes).

Let us see the differences between the three:

```java
public record BasketPlayer(String name, Float high) {
        //default constructor
        public BasketPlayer() {
            this("ND", null);
        }

        //custom constructor
        public BasketPlayer(String name) {
            this(name, null);
        }

        
        //compact canonical constructor (same result as previous)
        public BasketPlayer {
            if (Objects.isNull(name) || name.isBlank())
                throw new IllegalArgumentException("invalid name");
        }

    }
```

The syntax of the compact canonical constructor is a novelty aimed 
at the economical writing characteristic of records. The code above is equivalent to this:

```java
//canonical constructor
public BasketPlayer(String name, Float high) {
    if (Objects.isNull(name) || name.isBlank())
        throw new IllegalArgumentException("invalid name");

    this.name = name;
    this.high = high;
}
```
Basically, the compact form takes care of assigning the parameters passed ar arguments to the fields 
of the class. Either the compact or the extended form can be used, not both.

Let's try calling the different constructors.

```java
//default constructor
println(new BasketPlayer()); //BasketPlayer[name=ND, high=null]

// custom constructor
println(new BasketPlayer("Mattia")); //BasketPlayer[name=Mattia, high=null]

//canonical constructor
println(new BasketPlayer("Nicola", 1.74f)); //BasketPlayer[name=Nicola, high=1.74]

assertThrows(IllegalArgumentException.class, () -> new BasketPlayer(" "));
```

Another important difference between records and classes relates to deserialisation: for classes, persisted values are assigned directly to fields, whereas for records they are valorised via the canonical constructor.

__note__: Hibernate requires the presence of the default constructor to persist a class and __cannot persist records__. Why? Well, leaving aside a few technicalities such as lazy loading, the main reason is that Hibernate first instantiates the object (with the default constructor, so no parameters) then populates the fields, which is impossible for immutable fields.  
It is, however, possible to use records as a result of JPQL Criteria to project query results.






